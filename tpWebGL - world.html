<html><head>
<title>Système Solaire</title>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<script type="text/javascript" src="libs/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="libs/webgl-utils.js"></script>
<script type="text/javascript" src="obj/3Dobject.js"></script>
<script type="text/javascript" src="obj/sphere.js"></script>
<script type="text/javascript" src="obj/triangle.js"></script>
<script type="text/javascript" src="obj/square.js"></script>


<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

	varying vec2 vTextureCoord;

	uniform sampler2D uSampler;

    void main(void)
	{
		gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	varying vec2 vTextureCoord;

    void main(void)
	{
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTextureCoord = aTextureCoord;
    }
</script>


<script type="text/javascript">
	//GLOBALS
    var gl;
	var shaderProgram;
	
	var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();
	
	//textures
	var textureStars;
	var textureSun;
	var textureMercure;
	var textureVenus;
	var textureEarth;
	var textureMoon;
	var textureMars;
	var textureJupiter;
	var textureSaturne;
	var textureUranus;
	var textureNeptune;
		
	//interaction
	var drawStyle;
	
	var userRotationMatrix = mat4.create();
  	mat4.identity(userRotationMatrix);
	
	var rSun = 0;
	var rEarth = 0;

	var lastTime = 0;
	var mouseDown = false;
  	var lastMouseX = null;
  	var lastMouseY = null;
	var currentZoom = 1;

  	var toggleTriangle = true;
  	var toggleSquare= true;
  	var toggleSphere= true;
	
	var camX = 0;
	var camZ = 0;
	var camHeight = 0;

	//world
	var objects = [];
	var Sun;
	var Stars;
	
	//geometry
	var pasLat = 3;
	var pasLong = 6;
	var tetaMax = 360;
	var phiMax = 90;

	
	
	//SHADERS
    function initGL(canvas)
	{
        try
		{
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {}
        if (!gl)
		{
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function getShader(gl, id)
	{
        var shaderScript = document.getElementById(id);
        if (!shaderScript)
		{
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k)
		{
            if (k.nodeType == 3)
			{
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment")
		{
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex")
		{
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex")
		{
            shader = gl.createShader(gl.VERTEX_SHADER);
        }
		else
		{
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
		{
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

	function initShaders()
	{
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
		{
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
    }
	
	function mvPushMatrix()
	{
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix()
	{
        if (mvMatrixStack.length == 0)
		{
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms()
	{
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }
	
	
	//TEXTURES
	function initTexture()
	{
		textureStars = gl.createTexture();
		textureStars.image = new Image();
		textureStars.image.onload = function()
		{
		  handleLoadedTexture(textureStars)
		}

		textureSun = gl.createTexture();
		textureSun.image = new Image();
		textureSun.image.onload = function()
		{
		  handleLoadedTexture(textureSun)
		}

		textureMercure = gl.createTexture();
		textureMercure.image = new Image();
		textureMercure.image.onload = function()
		{
		  handleLoadedTexture(textureMercure)
		}

		textureVenus = gl.createTexture();
		textureVenus.image = new Image();
		textureVenus.image.onload = function()
		{
		  handleLoadedTexture(textureVenus)
		}

		textureEarth = gl.createTexture();
		textureEarth.image = new Image();
		textureEarth.image.onload = function()
		{
		  handleLoadedTexture(textureEarth)
		}

		textureMoon = gl.createTexture();
		textureMoon.image = new Image();
		textureMoon.image.onload = function()
		{
		  handleLoadedTexture(textureMoon)
		}

		textureMars = gl.createTexture();
		textureMars.image = new Image();
		textureMars.image.onload = function()
		{
		  handleLoadedTexture(textureMars)
		}

		textureJupiter = gl.createTexture();
		textureJupiter.image = new Image();
		textureJupiter.image.onload = function()
		{
		  handleLoadedTexture(textureJupiter)
		}

		textureSaturne = gl.createTexture();
		textureSaturne.image = new Image();
		textureSaturne.image.onload = function()
		{
		  handleLoadedTexture(textureSaturne)
		}
		
		textureSaturne = gl.createTexture();
		textureSaturne.image = new Image();
		textureSaturne.image.onload = function()
		{
		  handleLoadedTexture(textureSaturne)
		}
		
		textureUranus = gl.createTexture();
		textureUranus.image = new Image();
		textureUranus.image.onload = function()
		{
		  handleLoadedTexture(textureUranus)
		}
		
		textureNeptune = gl.createTexture();
		textureNeptune.image = new Image();
		textureNeptune.image.onload = function()
		{
		  handleLoadedTexture(textureNeptune)
		}
 
		textureStars.image.src = "./img/stars.jpg";
		textureSun.image.src = "./img/sun.jpg";
		textureMercure.image.src = "./img/mercure.jpg"; 
	    textureVenus.image.src = "./img/venus.jpg"; 
		textureEarth.image.src = "./img/earth.jpg";
	    textureMoon.image.src = "./img/moon.gif"; 
		textureMars.image.src = "./img/mars.jpg"; 
		textureJupiter.image.src = "./img/jupiter.jpg";
		textureSaturne.image.src = "./img/saturn.png";
		textureUranus.image.src = "./img/uranus.jpg";
		textureNeptune.image.src = "./img/neptune.jpg";
  }

	function handleLoadedTexture(texture)
	{
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}


	//INITGL
	
    function degToRad(degrees)
	{
        return degrees * Math.PI / 180;
    }


	function pol2Cart(longi, lat, resLongi, resLat)
	{
		return [
			Math.cos(degToRad(lat))*Math.sin(degToRad(longi)),
			Math.sin(degToRad(lat)),
			Math.cos(degToRad(lat))*Math.cos(degToRad(longi))
		];
	}

    function drawScene()
	{
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
        mat4.identity(mvMatrix);
		
		mat4.rotate(mvMatrix, -camHeight, [1, 0, 0]);
		
		mat4.translate(mvMatrix, [camX, 0, camZ]);
		//mat4.translate(mvMatrix, [0, -15, 0]);
		mat4.translate(mvMatrix, [0, 0.0, -25.0]);
		
		Stars.draw();
		Sun.draw();

		// gl.activeTexture(gl.TEXTURE0);
		//  gl.bindTexture(gl.TEXTURE_2D, textureEarth);
		//  gl.uniform1i(shaderProgram.samplerUniform, 0);
		 

		//  Sun.children.draw();


    }

	function initWorldObjects()
	{ 
		var obj = 12;
		var distSum=1;
		var distScale=1;
		var diamScale=5;

	    Stars = new sphere(null);
		Stars.translate([0,0,0]);
		Stars.scale([50,50,50]);
		Stars.texture = textureStars;
		objects.push(Stars);
		
		Sun = new sphere(null);
		Sun.translate([0,0,0]);
		Sun.scale([1,1,1]);
		Sun.texture = textureSun;
		Sun.rotatParam = 1/0.5;
		objects.push(Sun);

		var MercurePlanet = new sphere(Sun);
		var MercureDist = 0.357;
		var MercureDiam = 0.00350431;
		MercurePlanet.translate([(MercureDist*distScale)+distSum,0,0]);
		MercurePlanet.scale([MercureDiam*diamScale,MercureDiam*diamScale,MercureDiam*diamScale]);
		MercurePlanet.texture = textureMercure;
		MercurePlanet.orbitParam = 47.5;
		MercurePlanet.rotatParam = 1/58.65;
		objects.push(MercurePlanet);

		var VenusPlanet = new sphere(Sun);
		var VenusDist = 0.723;
		var VenusDiam = 0.008695402;
		VenusPlanet.translate([(VenusDist*distScale)+distSum,0,0]);
		VenusPlanet.scale([VenusDiam*diamScale,VenusDiam*diamScale,VenusDiam*diamScale]);
		VenusPlanet.texture = textureVenus;
		VenusPlanet.orbitParam = 35;
		VenusPlanet.rotatParam = 1/243.01;
		objects.push(VenusPlanet);

		var EarthPlanet = new sphere(Sun);
		var EarthDist = 1;
		var EarthDiam = 0.009163793;
		EarthPlanet.translate([(EarthDist*distScale)+distSum,0,0]);
		EarthPlanet.scale([EarthDiam*diamScale,EarthDiam*diamScale,EarthDiam*diamScale]);
		EarthPlanet.texture = textureEarth;
		EarthPlanet.orbitParam = 29.8;
		EarthPlanet.rotatParam = 1;
		objects.push(EarthPlanet);

		var MoonPlanet = new sphere(EarthPlanet);
		var MoonDist = 0.8;
		var MoonDiam = 0.02723;
		MoonPlanet.translate([(MoonDist*distScale)+distSum,0,0]);
		MoonPlanet.scale([MoonDiam*diamScale,MoonDiam*diamScale,MoonDiam*diamScale]);
		MoonPlanet.texture = textureMoon;
		MoonPlanet.orbitParam = 100;
		MoonPlanet.rotatParam = 1;
		objects.push(MoonPlanet);

		var MarsPlanet = new sphere(Sun);
		var MarsDist = 1.524;
		var MarsDiam = 0.004880747;
		MarsPlanet.translate([(MarsDist*distScale)+distSum,0,0]);
		MarsPlanet.scale([MarsDiam*diamScale,MarsDiam*diamScale,MarsDiam*diamScale]);
		MarsPlanet.texture = textureMars;
		MarsPlanet.orbitParam = 24.1;
		MarsPlanet.rotatParam = 1;
		objects.push(MarsPlanet);

		var JupiterPlanet = new sphere(Sun);
		var JupiterDist = 5.203;
		var JupiterDiam = 0.102586207;
		JupiterPlanet.translate([(JupiterDist*distScale)+distSum,0,0]);
		JupiterPlanet.scale([JupiterDiam*diamScale,JupiterDiam*diamScale,JupiterDiam*diamScale]);
		JupiterPlanet.texture = textureJupiter;
		JupiterPlanet.orbitParam = 13;
		JupiterPlanet.rotatParam = 1/0.4;
		objects.push(JupiterPlanet);

		var SaturnePlanet = new sphere(Sun);
		var SaturneDist = 9.05;
		var SaturneDiam = 0.086206897;
		SaturnePlanet.translate([(SaturneDist*distScale)+distSum,0,0]);
		SaturnePlanet.scale([SaturneDiam*diamScale,SaturneDiam*diamScale,SaturneDiam*diamScale]);
		SaturnePlanet.texture = textureSaturne;
		SaturnePlanet.orbitParam = 10;
		SaturnePlanet.rotatParam = 1/0.5;
		objects.push(SaturnePlanet);

		var UranusPlanet = new sphere(Sun);
		var UranusDist = 19.218;
		var UranusDiam = 0.036724138;
		UranusPlanet.translate([(UranusDist*distScale)+distSum,0,0]);
		UranusPlanet.scale([UranusDiam*diamScale,UranusDiam*diamScale,UranusDiam*diamScale]);
		UranusPlanet.texture = textureUranus;
		UranusPlanet.orbitParam = 7;
		UranusPlanet.rotatParam = 1/0.7;
		objects.push(UranusPlanet);

		var NeptunePlanet = new sphere(Sun);
		var NeptuneDist = 30.11;
		var NeptuneDiam = 0.03558046;
		NeptunePlanet.translate([(NeptuneDist*distScale)+distSum,0,0]);
		NeptunePlanet.scale([NeptuneDiam*diamScale,NeptuneDiam*diamScale,NeptuneDiam*diamScale]);
		NeptunePlanet.texture = textureNeptune;
		NeptunePlanet.orbitParam = 5.5;
		NeptunePlanet.rotatParam = 1/0.8;
		objects.push(NeptunePlanet);

		/*for (var i=0; i < obj; i++)
		{ 
			var newObject = new triangle(rootObject);
			objects.push(newObject);
			newObject.rotate(-i*Math.PI/12, [0,0,1])
			newObject.translate([2,0,i/100])
			newObject.scale([1-i/12,1-i/12,1-i/12])
		}
		
		var newObject = new square(rootObject);
		objects.push(newObject);
		newObject.translate([0,2,0]);
		
		newObject = new sphere(rootObject);
		objects.push(newObject);
		newObject.translate([2,2,0]);*/

		return Sun;
	}
	
    function animate()
	{
        var timeNow = new Date().getTime();
		var elapsed = 0;
        if (lastTime != 0)
		{
            elapsed = timeNow - lastTime;

            //rTri += (90 * elapsed) / 1000.0;
            //rSquare += (75 * elapsed) / 1000.0;
			rSun += (50 * elapsed) / 1000.0;
			rEarth += (50 * elapsed) / 400.0;
        }
		
		Sun.animate(elapsed);
		lastTime = timeNow;
    }

    function tick() {
        requestAnimFrame(tick);
        drawScene();
        animate();
    }

	function webGLStart() {

        var canvas = document.getElementById("lesson03-canvas");

		//webGL
        initGL(canvas);
        initShaders();
        initTexture();
		Sun = initWorldObjects();
		

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

		//interactions
		canvas.onmousedown = handleMouseDown;
	    document.onmouseup = handleMouseUp;
	    document.onmousemove = handleMouseMove;
	    canvas.onmousewheel = handleWheel;
		window.addEventListener("keydown", handleKeyDown, false);
		drawStyle = gl.TRIANGLES;
        tick();
    }
		
	//interactions
  	function handleMouseDown(event) {
    	mouseDown = true;
    	lastMouseX = event.clientX;
    	lastMouseY = event.clientY;
  	}

  	function handleMouseUp(event) {
    	mouseDown = false;
  	}

  	function handleMouseMove(event)
  	{
		if (!mouseDown) {
		  return;
		}
		var newX = event.clientX;
		var newY = event.clientY;


		var newRotationMatrix = mat4.create();
		mat4.identity(newRotationMatrix);

		var deltaX = newX - lastMouseX;
		mat4.rotate(newRotationMatrix, degToRad(deltaX / 7), [0, 1, 0]);

		var deltaY = newY - lastMouseY;
		mat4.rotate(newRotationMatrix, degToRad(deltaY / 7), [1, 0, 0]);

		mat4.multiply(newRotationMatrix, userRotationMatrix, userRotationMatrix);

		lastMouseX = newX;
		lastMouseY = newY;

    }

    function handleWheel(event)
    {
		event.preventDefault();
    	currentZoom*=1+(event.wheelDelta/Math.abs(event.wheelDelta))/10;
    }

	function handleKeyDown(event)
    {
    	//console.log(event.keyCode);
    	event.preventDefault();
    	switch(event.keyCode)
    	{
			case 37: //left
					camX++;
					break;
			case 39: //right
					camX--;
					break;
			case 38: //down
					camZ++;
					break;
			case 40: //forward
					camZ--;
					break;
			case 33: //pageUp
					camHeight+=degToRad(1);
					break;
			case 34: //pageDown
					camHeight-=degToRad(1);
					break;

				default:

		}
    }
	

	function drawCombo(list)
	{
		drawStyle = list.selectedIndex;
	}

	function handleClick(checkMesh)
	{
		switch(checkMesh.value)
		{
			case 'triangle':
			        toggleTriangle = checkMesh.checked;
			        break;
			case 'square':
			        toggleSquare = checkMesh.checked;
			        break;
			case 'sphere':
			        toggleSphere = checkMesh.checked;
			        break;
			    default:
		}
	}

	function handleSlider1(sliderValue)
	{
		// à faire	
	}
</script>

</head>


<body onload="webGLStart();">
	<table border="0" width="100%">

		<tr><td style="width:500px">
			<canvas id="lesson03-canvas" style="border: none;" width="1100" height="500"></canvas>
			</td>
			<td>
			<input type="range" min="0" max="100" value="100" step="1" oninput="handleSlider1(this.value)"/>
			<br />
			<input type="checkbox" name="mesh" value="triangle" onclick='handleClick(this)' checked=true/>Triangle<br />
			<input type="checkbox" name="mesh" value="sphere" onclick='handleClick(this)' checked="true">Sphere<br />
			<input type="checkbox" name="mesh" value="square" onclick='handleClick(this)' checked=1/>Square<br />

			<br />
			Draw mode <select id="drawCombo" onChange="drawCombo(this)">
				<option id="option1">POINTS</option>
				<option id="option2">LINES</option>
				<option id="option3">LINE_LOOP</option>
				<option id="option4">LINE_STRIP</option>
				<option selected="selected" id="option5">TRIANGLES</option>
				<option id="option6">TRIANGLE_STRIP</option>
				<option id="option7">TRIANGLE_FAN</option>
			</select>
			</td>
		</tr>

</table>



</body></html>